https://courses.cs.washington.edu/courses/csep527/20au/hw/hw5.html
## Goal
For a specific prokaryotic genome, you are going to identify 

1. all plus-strand open reading frames (ORFs)
2. score each according to a Markov model trained on a subset of the genome, and 
3. attempt to classify all plus-strand ORFs as "real" protein-coding genes or not based on 

    1. ORF length, 
    2. MM score, or a 
    3. combination of both
, and then 
4. evaluate the success of the classification based on a trusted annotation of the genome obtained from Genbank. 

## Plan

1. Find ORFs based on reading frames
2. store them in pandas dataframe along with their length,start, end
3. create markov model using long ORFs.
4. Parse gff file to find read gene positions. create a set with end position as key.
5. build a table containing, for each ORF, a summary consisting of its starting/ending coordinates, length and Markov model score, together with its status (is/is not among the "simple plus strand CDSs" in the .gff file).
6. Create ROC table. Zoomed in and our version
7. create scatter plots. Calculate splits
## Idea #1: look for long open reading frames (ORFs).

### Definition 
ORF: An ORF is a (maximal length) sequence of consecutive nucleotide triplets, none of which is a stop codon (TAA, TAG, or TGA).

Maximal length: implies that the triplets immediately preceding and immediately following an ORF are stop codons
(or that there is no adjacent triplet, as will happen at the beginning and end of the genome sequence)

### Assumption
In prokaryotes (bacteria and archea), essentially every protein-coding gene falls at the end of an ORF. (As promised, we are simplifying, principly in that we aren't going to bother to look for the start codon.)

### How to find ORFs?
ORFs are easy to find. 

1. Starting at the leftmost triplet of the genome, scan successive, adjacent, non-overlapping triplets until you find a stop; 
2. then continue until you find another stop, etc. 
3. Those are all the ORFs whose start positions have indices congruent to 1 mod 3. 
4. Then repeat the whole process from the left end again, but omitting the very first, or first two, nucleotides (to account for the other two possible reading frames, congruent to 2 mod 3 and 0 mod 3, resp.)

### Assumption
One should also repeat this from the right end on the Watson-Crick complement of the sequence; again in the interest of simplicity, we're going to completely ignore that.

### Program
The first part of this problem is to 

1. write a program to do the above process. 
2. We will use the genome sequence of Methanocaldococcus jannaschii, the same one you downloaded for HW 
3. Again, ignore the two shorter plasmid sequences at the end of the .fna file, and treat nucleotide symbols other than A, C, G as T. 
4. Record the indices of the first and last nucleotide in each ORF you find. (Recall, by convention, genome indices are 1-based, not 0-based.)

## Idea #2: Look for ORFs having sequence statistics that are more typical of known genes than of noncoding DNA.

A k-th order Markov model predicts successive letters in a sequence based on the previous k letters. Specifically, for `k=3`, say, the probability of sequence `x = x1 x2 ... xn` is

    P(x) = P(x1 x2 x3) * P(x4 | x1 x2 x3) * P(x5 | x2 x3 x4) ... P(xn | xn-3 xn-2 xn-1)

likelihood ratio test,
`log(P(x)/Q(x)) > 0` implies that the sequence is more likely to have been generated by the gene model than the background model.

### Where do the probabilities P come from? 

1. Simply take a "trusted" set of example genes and count the frequencies of all (k+1)-letter (contiguous) subsequences.

    E.g., if k=2 and your training set is just the one sequence AAAAGCTA, then AAA occurs twice, and AAG, AGC, GCT, and CTA each occur once, so P(A | AA) = 2/3, P(G | AA) = 1/3, P(A | CT) = 1/1, etc. Estimate unconditional probabilities for k-letter sub-sequences in the same way. E.g., 3/7 of the adjacent letter pairs in the training set are AA so P(AA) = 3/7, P(AG) = 1/7, etc. 

2. Take as your trusted set all long ORFs (defined, arbitrarily, as those longer than 1400 nucleotides); most or all of them are real genes. 
3. As your background frequencies, apply the same process to the reverse complement of all long ORFs. 

### Two notes: 

1. First, the "natural" thing to do to estimate P(x1x2...xk) is to base it on only the first k letters of the training sequences. However, (continuing the k=2 example) with only that one training sequence, you would end up with P(AA)=1, and the probability of every other letter pair being zero. This is appropriate if you are confident that all instances start with AA, but not if the available set of training samples is not comprehensive enough to be fully representative. The suggestion above ("count k-mers throughout the training sequence(s), not just at their starts"), is basically equivalent to assuming that the starts of sequences are statistically indistinguishable from their interiors.\

2. My second note is that there are other strategies for dealing with sparse training data. "Pseudocounts" (discussed in lecture) are a prominent example but I think there's enough training data in the M. jannaschii example that they are unnecessary, albeit unharmful. Extra credit option: explore alternative choices here.

Professor changed this and asked to add pseudo count of 1
        
        count(X|YZ) += 1
        count(YZ) += 4

### Program
Calculate the P and Q tables as above for k=5, then compute log(P(x)/Q(x)) for each ORF of length k or greater (the ORF's Markov model score; for comparability of results, use natural logs this time).

## Evaluation

    head -n 3700 *gff | grep "Protein Homology	CDS	[0-9]*	[0-9]*	.	+" > plusgenes-subset.gff
    
Procedurally, I suggest you build a table containing, for each ORF (there are around 105 of them), a summary consisting of its starting/ending coordinates, length and Markov model score, together with its status (is/is not among the "simple plus strand CDSs" in the .gff file).

## Outputs: 
So much data, so little time. What to do with it, how to summarize it?

1. This sort of analysis has an unusually large number of opportunities for "off-by-one" and other subtle errors. To help with debugging and grading, calculate, print and turn-in the following simple diagnostic parameters. You may post (a)-(f) on the Canvas discussion board so that you can help each other get past these potential nuisance bugs. For the following, I (arbitrarily) define "short ORFs" to be those of length less than 50, and "long ORFs" to be those of length greater than 1400. Print:
    1. for each of the three reading frames, the number of ORFs you find, and the summary of the first and last of each
    2. the total number of short ORFs (length less than 50),
    3. the total number of long ORFs (length greater than 1400),
    4. the total number of "simple plus strand CDSs" you found in GenBank,
    an (arbitrarily chosen) sample of the counts you accumulate that factor into calculating the conditional probabilities, specifically P(T | AAGxy), Q(T | AAGxy) for the 16 possible combinations of x,y in A,C,G,T. (To be clear, AAG are the leftmost three nucleotides of the 5 preceding the putative "T".) For consistency, please print this as a 4 x 4 table with rows for x = A, C, G, T in that order, and columns for y in the same order, and
    5. your summary data for the first 5 short ORFs and the first 5 long ORFs. "First 5" means "the 5 with the smallest start coordinate." Your summary of each ORF should include its start coordinate, end cordinate, length, log-base-e Markov model score and a flag indicating whether this ORF was/was not among the "simple plus strand CDSs" in GenBank.
Generate a single plot showing ROC curves with respect to (a) length threshold, say in red, and (b) Markov model score, say in green, using the full 0-1 range for both axes. Additionally, (c) generate such a plot "zoomed-in" to the upper-left corner to show the crossover between the two curves. For maximum clarity, you probably do not want the two axes to be equally scaled in the "zoomed" view. (Step (c) is important since there are many, many more short ORFs (mostly non-genes) than long ones (mostly real genes), which drives the ROC curves into the upper-left corner.) Also calculate and show Area Under the Curve (AUC) for each curve.